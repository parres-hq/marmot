# MIP-01

## Basic MLS messaging over Nostr

`draft` `mandatory`

This document defines the core protocol for secure group messaging by combining MLS (Messaging Layer Security) with Nostr's distributed relay network. This is one of only two required MIPs that MUST be implemented by all projects wanting to be interoperable.

## Overview

MLS provides the cryptographic foundation for secure group messaging, while Nostr provides the decentralized transport layer. This combination enables:

- **Secure groups**: End-to-end encrypted messaging with forward secrecy
- **Decentralized**: No central servers or single points of failure
- **Interoperable**: Works across different clients and implementations
- **Scalable**: Efficient for groups of various sizes

### How it works

1. **Setup**: Users publish KeyPackages to advertise their ability to join groups
2. **Group creation**: Admins create groups with specific security parameters
3. **Invitations**: New members are added using their published KeyPackages
4. **Messaging**: All group communication happens through encrypted Group Events
5. **Group management**: Admins can add/remove members and update group settings

## Creating groups

### Group Identity and Privacy

Every MLS group has a unique 32-byte ID that serves as its permanent identifier. This ID is:
- **Private**: Never published to relays in any form
- **Permanent**: Cannot be changed once the group is created
- **Random**: Generated using secure randomness

### Compatibility Requirements

Before creating a group, clients must verify compatibility with intended members by checking their published `KeyPackage` events. This ensures all members support the same:
- **Ciphersuite**: Cryptographic algorithms used for the group
- **Capabilities**: MLS features the group will use
- **Extensions**: Additional functionality required by the group

### Required MLS Extensions

All groups MUST include these MLS extensions:

- [`required_capabilities`](https://docs.rs/openmls/latest/openmls/extensions/struct.RequiredCapabilitiesExtension.html) - Defines what MLS features all members must support
- [`ratchet_tree`](https://docs.rs/openmls/latest/openmls/extensions/struct.RatchetTreeExtension.html) - Manages the cryptographic key tree structure
- [`nostr_group_data`](https://github.com/parres-hq/mdk/blob/master/crates/mdk-core/src/extension.rs) - Links MLS groups to Nostr-specific data (see [MIP-02](02.md))

### Group State Changes

Group modifications follow a two-step process:

1. **Proposal**: Any member can propose changes (add/remove members, update settings)
2. **Commit**: An admin commits to a set of proposals, making them official

While these are MLS operations, `Commit` events must be published to Nostr relays so all members can see and process the changes. See [Group Events](#group-events) for details.

## MLS Credentials

### What are Credentials?

An MLS `Credential` proves a user's identity within the group and includes their signing key. Think of it as a secure ID card that also contains a key for signing messages.

### Identity Requirements

When creating credentials, clients MUST:

- **Use BasicCredential type**: The standard MLS credential format
- **Set identity to Nostr pubkey**: Use the 32-byte hex-encoded public key of the user's Nostr identity
- **Keep identity immutable**: Never allow changes to the identity field
- **Validate proposals**: Reject any `Proposal` that attempts to change identity fields

### Signing Keys

Each credential includes a signing key that:

- **Must be unique**: Different from the user's Nostr identity key
- **Signs MLS messages**: Used for all communications within the group
- **Should rotate regularly**: Improves security if a key is compromised
- **Starts in KeyPackage**: Initial signing key comes from the user's published KeyPackage event

> **Security Note**: Regular signing key rotation provides better forward-secrecy and post-compromise security, limiting the impact if a key is exposed.

## Nostr Group Data Extension

The `nostr_group_data` extension bridges MLS groups with Nostr by securely linking Nostr-specific information to the MLS group state. This extension:

- **Is mandatory**: MUST be included in all groups
- **Is cryptographically secure**: Changes are authenticated and tamper-proof
- **Stores Nostr metadata**: Contains information like group admins and Nostr-specific settings

This extension MUST be included as a required capability when creating any new group.

> **Learn more**: See [MIP-02](02.md) for detailed information about the group data extension.

## KeyPackage Events and Signing Keys

### What are KeyPackages?

A `KeyPackage` is like a public invitation card that tells others "you can add me to groups". Every user who wants to receive group invites MUST publish at least one `KeyPackage` event to Nostr relays.

### How KeyPackages Work

KeyPackages enable asynchronous group invitations by:

- **Advertising capabilities**: Shows what ciphersuites and extensions the user supports
- **Providing credentials**: Contains the user's MLS credential for authentication
- **Including signing keys**: Contains a unique signing key (different from Nostr identity key)
- **Supporting multiple configs**: Users can publish multiple KeyPackages with different parameters

### KeyPackage Consumption and Reuse

**Normal usage**: A `KeyPackage` is "consumed" (used up) when someone joins a group with it.

**Race condition problem**: Multiple group invites might try to use the same KeyPackage simultaneously.

**Solution**: Use the "last resort" flag with the [`last_resort`](https://docs.rs/openmls/latest/openmls/extensions/struct.LastResortExtension.html) extension, which allows a KeyPackage to be reused when necessary.

### Key Management Requirements

Clients MUST:

- **Rotate signing keys quickly**: Change the signing key soon after joining via a last resort KeyPackage
- **Retain private keys**: Keep access to signing key private material for all groups
- **Manage KeyPackage lifecycle**: Automatically create and rotate KeyPackages

> **Security Note**: Quick signing key rotation after using a last resort KeyPackage maintains strong post-compromise security.

### Example KeyPackage Event

```json
{
  "id": "abc123...",
  "kind": 443,
  "created_at": 1693876543,
  "pubkey": "02a1633cafe37eeebe2b39b4ec5f3d74c35e61fa7e7e6b7b8c5f7c4f3b2a1b2c3d",
  "content": "0123456789abcdef...",
  "tags": [
    ["mls_protocol_version", "1.0"],
    ["ciphersuite", "0x0001"],
    ["extensions", "0x0001", "0x0002", "0x0003"],
    ["client", "MyMLSClient", "event123...", "wss://relay.example.com"],
    ["relays", "wss://relay1.com", "wss://relay2.com"],
    ["-"]
  ],
  "sig": "304502210..."
}
```

### Field Explanations

**Required fields:**
- **`content`**: Hex-encoded TLS-serialized `KeyPackageBundle` from your MLS implementation
- **`mls_protocol_version`**: MLS protocol version - currently `1.0`
- **`ciphersuite`**: MLS ciphersuite ID (see [MLS spec](https://www.rfc-editor.org/rfc/rfc9420.html#name-mls-cipher-suites))
- **`extensions`**: Array of supported MLS extension IDs (see [MLS spec](https://www.rfc-editor.org/rfc/rfc9420.html#name-extensions))
- **`relays`**: Relay URLs where this KeyPackage is published (needed for later deletion)

**Optional fields:**
- **`client`**: Client info to help with UX when users can't access signing keys (may be omitted for privacy)
- **`-`**: Ensures only the author can publish this event (see [NIP-70](70.md))

### KeyPackage Lifecycle Management

#### When to Delete KeyPackages

Clients SHOULD delete KeyPackages from relays when:

- **Successfully joining a group**: Delete the KeyPackage after processing a `Welcome` message
- **Creating new KeyPackages**: Optionally replace old ones with fresh KeyPackages

#### When NOT to Delete KeyPackages

Clients MUST NOT delete KeyPackages when:

- **Welcome processing fails**: If you can't process a Welcome message (e.g., signing key generated on another device)
- **Show clear errors**: Display user-friendly error messages explaining the issue

### Signing Key Rotation

#### Why Rotate Keys?

Regular signing key rotation strengthens security by:
- **Limiting compromise impact**: Reduces damage if a key is exposed
- **Improving forward secrecy**: Past messages remain secure even if current keys are compromised
- **Following MLS best practices**: Takes advantage of MLS's built-in security features

#### How to Rotate Keys

1. **Create Proposal**: Propose a key update for your leaf node
2. **Commit changes**: Include the proposal in a Commit message
3. **Broadcast to group**: Publish the Commit via a Group Event

Clients SHOULD rotate signing keys regularly in all groups they participate in.

> **Learn more**: See the [MLS RFC section on forward secrecy](https://www.rfc-editor.org/rfc/rfc9420.html#name-forward-secrecy-and-post-co) for deeper technical details.

### KeyPackage Relays List Event

Users publish a `kind: 10051` event to advertise which relays contain their KeyPackages. This helps others know where to look for your KeyPackages when they want to invite you to groups.

#### Requirements

- **Include relay tags**: List all relays where you publish KeyPackages
- **Make them accessible**: These relays SHOULD be readable by anyone you want to receive invites from
- **Keep updated**: Update this list when you change your relay setup

#### Example Relays List Event

```json
{
  "kind": 10051,
  "tags": [
    ["relay", "wss://inbox.nostr.wine"],
    ["relay", "wss://myrelay.nostr1.com"]
  ],
  "content": "",
  "created_at": 1693876543,
  "pubkey": "02a1633cafe37eeebe2b39b4ec5f3d74c35e61fa7e7e6b7b8c5f7c4f3b2a1b2c3d",
  "sig": "304502210..."
}
```

### Welcome Events

#### Purpose and Flow

When someone adds a new member to a group, they must send that person a `Welcome` Event. This event provides everything the new member needs to join the group and start participating.

**The process:**
1. **Admin commits**: Group admin includes a new member via a `Commit` message
2. **Wait for confirmation**: Admin waits for relay acknowledgment of the Group Event
3. **Send Welcome**: Admin sends a private `Welcome` Event to the new member
4. **New member joins**: New member processes the Welcome and can start messaging

#### Privacy and Security

Welcome Events are sent as [NIP-59](https://github.com/nostr-protocol/nips/blob/master/59.md) gift-wrapped events to ensure:
- **Privacy**: Only the intended recipient can read the welcome
- **Unlinkability**: Observers can't tell who is being invited to what group

#### Welcome Event Structure

```json
{
  "id": "def456...",
  "kind": 444,
  "created_at": 1693876600,
  "pubkey": "02a1633cafe37eeebe2b39b4ec5f3d74c35e61fa7e7e6b7b8c5f7c4f3b2a1b2c3d",
  "content": "0987654321fedcba...",
  "tags": [
    ["e", "keypackage_event_id_123..."],
    ["relays", "wss://relay1.com", "wss://relay2.com"]
  ]
}
```

**Important**: This event is NOT signed (`"sig"` field omitted) to prevent accidental public publishing if it leaks.

#### Field Details

- **`content`**: Hex-encoded serialized `MLSMessage` containing the MLS `Welcome` object
- **`e` tag**: ID of the KeyPackage Event used to add this user
- **`relays` tag**: List of relays where the new member should look for Group Events

#### Timing Requirements

Clients creating Welcome Events MUST:
1. **Wait for confirmation**: Don't send the Welcome until relays confirm receipt of the Commit
2. **Process before welcoming**: Ensure the group state change is committed before inviting

> #### Large Groups
>
> For groups above ~150 participants, welcome messages will become larger than is permitted by many Nostr relays. There is currently work underway on the MLS protocol to support "light" client `Welcome` objects that don't require the full Ratchet Tree state to be sent to the new member. This section will be updated with recommendations for how to handle large groups.

## Group Events

Group Events are how members communicate within a group. They include:

- **Control messages**: `Proposal` and `Commit` messages that update group membership and settings
- **Application messages**: Regular chat messages, reactions, and other content shared between members

### Privacy Protection

To protect member privacy, Group Events use special techniques:

- **Ephemeral keys**: Each Group Event uses a fresh, one-time Nostr keypair
- **Content encryption**: Messages are encrypted so only group members can read them
- **Metadata protection**: Observers can't easily determine group size or member identities

### Group Event Structure

```json
{
  "id": "ghi789...",
  "kind": 445,
  "created_at": 1693876700,
  "pubkey": "03b2c4d6e8f0a1b3c5d7e9f1a3b5c7d9e1f3a5b7c9d1e3f5a7b9c1d3e5f7a9b1c3",
  "content": "a1b2c3d4e5f6...",
  "tags": [
    ["h", "group_id_from_nostr_extension"]
  ],
  "sig": "506070809..."
}
```

### Encryption Details

#### Content Encryption Process

1. **Get group secret**: Use the MLS `exporter_secret` from the current group epoch
2. **Generate keypair**: Create a Nostr keypair using the exporter_secret as the private key
3. **Apply NIP-44**: Encrypt the MLSMessage using the standard NIP-44 scheme
4. **Publish**: Send the encrypted content to relays

#### Key Technical Details

- **`content`**: Serialized [`MLSMessage`](https://www.rfc-editor.org/rfc/rfc9420.html#section-6-4) encrypted with [NIP-44](44.md)
- **`exporter_secret`**: 32-byte value labeled `nostr`, rotates with each group epoch
- **`pubkey`**: Ephemeral public key (different for each Group Event)
- **`h` tag**: Group ID from the Nostr Group Data Extension

> **Security Note**: The `exporter_secret` ensures only current group members can decrypt messages, and it rotates automatically when the group state changes.

### Proposal and Commit Messages

#### Two-Phase Group Changes

Group modifications use a two-phase approach for safety and coordination:

1. **Proposal Phase**: Members suggest changes
2. **Commit Phase**: Admins approve and apply changes

#### Proposal Messages

**Who can propose**: Any group member can create proposals

**What proposals do**:
- Suggest adding new members
- Propose removing members
- Recommend changing group settings
- Request key rotations

**Proposal lifecycle**:
- Created by any member
- Stored for review
- Included (or rejected) in future Commits

#### Commit Messages

**Who can commit**: Only group admins can create and send Commits

**What commits do**:
- Apply one or more pending proposals
- Update the group's cryptographic state
- Move the group to a new "epoch" (version)

**Security requirements**:
- Sender MUST be listed in `admin_pubkeys` (see [MIP-02](02.md))
- Clients MUST verify admin status before processing any Commit
- Invalid Commits from non-admins MUST be rejected

> **Admin Control**: This design ensures only authorized admins can make actual changes to groups, while still allowing all members to participate in governance through proposals.

### Application Messages

#### What are Application Messages?

Application messages are the regular content shared within groups - chat messages, reactions, media sharing, and any other member-to-member communication.

#### Message Format

Application messages use standard Nostr event formats inside the encrypted MLS envelope:

- **Chat messages**: `kind: 9` events for regular text messages
- **Reactions**: `kind: 7` events for emoji reactions to other messages
- **Other content**: Any appropriate Nostr event kind

#### Benefits of Nostr Events Inside MLS

This approach provides the best of both worlds:
- **MLS security**: End-to-end encryption and forward secrecy
- **Nostr features**: Rich event types, reactions, threading, and extensibility
- **Familiar handling**: Clients can reuse existing Nostr event processing logic

#### Security Requirements

**Identity verification**:
- Inner events MUST use the sender's Nostr identity key in the `pubkey` field
- Clients MUST verify the MLS sender matches the inner event's pubkey

**Prevent leaks**:
- Inner events MUST remain **unsigned** (no `sig` field)
- MUST NOT include `h` tags or other group identifiers
- This ensures leaked events cannot be published to public relays

#### Example Flow

1. **Create**: Member creates a `kind: 9` chat message event (unsigned)
2. **Wrap**: Event is serialized and wrapped in an MLS Application message
3. **Encrypt**: MLS message is encrypted and sent as a Group Event
4. **Decrypt**: Recipients decrypt and deserialize to get the original Nostr event
5. **Store**: Clients can store and display the event like any other Nostr content

### Commit Message Race Conditions

#### The Challenge

While MLS handles most out-of-order messages gracefully, `Commit` message ordering is critical for proper group state progression. In Nostr's decentralized environment, multiple admins might send competing Commits simultaneously.

#### Prevention Strategy

**Wait for confirmation**: Clients sending Commits MUST:
1. **Send the Group Event**: Publish the Commit as a Group Event to relays
2. **Wait for acknowledgment**: Don't apply the Commit locally until at least one relay confirms receipt
3. **Then apply locally**: Only then update your own group state

#### Conflict Resolution

When receiving multiple Commits for the same epoch, clients MUST apply exactly one using this priority:

1. **Timestamp priority**: Choose the Commit with the earliest `created_at` timestamp
2. **ID tiebreaker**: If timestamps are identical, choose the Commit with the lexicographically smallest `id`
3. **Discard others**: Reject all other competing Commits

#### Recovery Mechanism

**State backup**: Clients SHOULD retain previous group states temporarily to enable recovery from forked states.

**Example scenario**:
- Admin A and Admin B both send Commits at timestamp 1693876800
- Admin A's Commit has ID "aaa123...", Admin B's has "bbb456..."
- All clients apply Admin A's Commit (lexicographically smaller ID)
- Admin B's Commit is discarded

> **Consistency Note**: This deterministic ordering ensures all honest clients converge on the same group state, even with competing Commits.

---

## Summary

This MIP defines how to build secure, decentralized group messaging by combining MLS and Nostr. Here are the key concepts:

### Core Components

1. **KeyPackages** (`kind: 443`): Advertise your ability to join groups
2. **Welcome Events** (`kind: 444`): Private invitations to join groups
3. **Group Events** (`kind: 445`): All group communication (encrypted)
4. **Relay Lists** (`kind: 10051`): Where to find your KeyPackages

### Security Features

- **End-to-end encryption**: Only group members can read messages
- **Forward secrecy**: Past messages stay secure even if keys are compromised
- **Privacy protection**: Ephemeral keys hide member identities from observers
- **Admin controls**: Only authorized admins can modify group membership

### Key Requirements for Implementers

**MUST implement**:
- Required MLS extensions: `required_capabilities`, `ratchet_tree`, `nostr_group_data`
- Proper credential management with Nostr identity keys
- Admin verification for all Commit messages
- Race condition handling for competing Commits
- Regular signing key rotation

**Security considerations**:
- Never reuse ephemeral keypairs for Group Events
- Keep MLS group IDs private (never publish to relays)
- Verify all admin permissions before processing Commits
- Handle unsigned inner events to prevent leaks

This foundation enables interoperable, secure group messaging across different Nostr clients while maintaining the decentralized nature of the Nostr network.
