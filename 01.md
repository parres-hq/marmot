# MIP-01

## Basic MLS messaging over Nostr

`draft` `mandatory`

This document covers the basic protocol flow for creating and managing MLS groups using Nostr's distributed relay network. This is one of only two required MIPs that MUST be implemented by all projects wanting to be interoperable.

## Creating groups

At the MLS layer, groups are created with a random 32-byte ID value that is effectively permanent. This ID should be treated as private to the group and MUST not be published to relays in any form.

Clients must also ensure that the ciphersuite, capabilities, and extensions they use when creating the group are compatible with those advertised by the users they'd like to invite to the group. They can check this info via the user's published `KeyPackage` events.

When creating a new group, the following MLS extensions MUST be used.

- [`required_capabilities`](https://docs.rs/openmls/latest/openmls/extensions/struct.RequiredCapabilitiesExtension.html)
- [`ratchet_tree`](https://docs.rs/openmls/latest/openmls/extensions/struct.RatchetTreeExtension.html)
- [`nostr_group_data`](https://github.com/parres-hq/mdk/blob/master/crates/mdk-core/src/extension.rs)

Changes to an MLS group are affected by first creating one or more `Proposal` events and then committing to a set of proposals in a `Commit` event. These are MLS events, not Nostr events. However, for the group state to properly evolve the Commit events (which represent a specific set of proposals - like adding a new user to the group) must be published to relays for the other group members to see. See [Group Messages](#group-events) for more information.

## MLS Credentials

A `Credential` in MLS is an assertion of who the user is, coupled with a signing key. When constructing `Credentials` for MLS, clients MUST use the `BasicCredential` type and set the `identity` value as the 32-byte hex-encoded public key of the user's Nostr identity key. Clients MUST not allow users to change the identity field and MUST validate that all `Proposal` messages do not attempt to change the identity field on any credential in the group.

A `Credential` also has an associated signing key. The initial signing key for a user is included in the Key Package event. The signing key MUST be different from the user's Nostr identity key. This signing key SHOULD be rotated over time to provide improved post-compromise security.

## Nostr Group Data Extension

As mentioned above, the `nostr_group_data` extension is a required MLS extension used to associate Nostr-specific data with an MLS group in a cryptographically secure and proveable way. This extension MUST be included as a required capability when creating a new group.

Read more about the group data extension in [MIP-02](02.md).

## KeyPackage Event and Signing Keys

Each user that wishes to be reachable via MLS-based messaging MUST first publish at least one `KeyPackage` event. The `KeyPackage` event is used to authenticate users and share the necessary `Credential` to add members to groups in an asynchronous way. Users can publish multiple `KeyPackage` Events with different parameters (supporting different ciphersuites or MLS extensions, for example). KeyPackages include a signing key that is used for signing MLS messages within a group. This signing key MUST not be the same as the user's Nostr identity key.

`KeyPackage` reuse SHOULD be minimized. However, in normal MLS use, A `KeyPackage` is consumed when joining a group. In order to reduce race conditions between invites for multiple groups using the same `KeyPackage`, clients SHOULD use "last resort" flag on `KeyPackage` objects. This requires the inclusion of the [`last_resort`](https://docs.rs/openmls/latest/openmls/extensions/struct.LastResortExtension.html) flag when creating the KeyPackage.

It's important that clients rotate a user's signing key as soon as possible after joining a group via a last resort key package to maintain and improve post-compromise security. The signing key (the public key included in the `KeyPackage` Event) is used for signing within the group. Therefore, clients implementing this MIP MUST ensure that they retain access to the private key material of the signing key for each group they are a member of.

In most cases, it's assumed that clients implementing this MIP will manage the creation and rotation of `KeyPackage` Events.

### Example KeyPackage Event

```json
  {
    "id": <id>,
    "kind": 443,
    "created_at": <unix timestamp in seconds>,
    "pubkey": <main identity pubkey>,
    "content": <hex-encoded TLS-serialized KeyPackage object>,
    "tags": [
        ["mls_protocol_version", "1.0"],
        ["ciphersuite", <MLS CipherSuite ID value e.g. "0x0001">],
        ["extensions", <An array of MLS Extension ID values e.g. "0x0001, 0x0002">],
        ["client", <client name>, <handler event id>, <optional relay url>],
        ["relays", <array of relay urls>],
        ["-"]
    ],
    "sig": <signed with nostr identity key>
}
```

- The `content` field is the hex-encoded, TLS serialized `KeyPackageBundle` from your MLS implementation.
- The `mls_protocol_version` tag is required and MUST be the version number of the MLS protocol version being used. For now, this is `1.0`.
- The `ciphersuite` tag is the value of the MLS ciphersuite that this `KeyPackage` Event supports. [Read more about ciphersuites in MLS](https://www.rfc-editor.org/rfc/rfc9420.html#name-mls-cipher-suites).
- The `extensions` tag is an array of MLS extension IDs that this `KeyPackage` Event supports. [Read more about MLS extensions](https://www.rfc-editor.org/rfc/rfc9420.html#name-extensions).
- (optional) The `client` tag helps other clients manage the user experience when they receive group invites but don't have access to the signing key. For privacy reasons, clients may not want to include this.
- The `relays` tag identifies each of the relays that the client will attempt to publish this `KeyPackage` event. This allows for deletion of KeyPackage Events at a later date.
- (optional) The `-` tag can be used to ensure that `KeyPackage` Events are only published by their authenticated author. Read more in [NIP-70](70.md)

### Deleting KeyPackage Events

Clients SHOULD delete the `KeyPackage` Event on all the listed relays any time they successfully process a `Welcome` message using a given `KeyPackage` Event. Clients MAY also create a new `KeyPackage` Event at the same time.

If clients cannot process a Welcome message (e.g. because the signing key was generated on another client), clients MUST not delete the `KeyPackage` Event and SHOULD show a human-understandable error to the user.

### Rotating Signing Keys

Clients MUST regularly rotate the user's signing key in each group that they are a part of. The more often the signing key is rotated the stronger the post-compromise security. This rotation is done via `Proposal` and `Commit` events and broadcast to the group via a Group Event. [Read more about forward secrecy and post-compromise security inherent in MLS](https://www.rfc-editor.org/rfc/rfc9420.html#name-forward-secrecy-and-post-co).

### Key Package Relays List Event

A `kind: 10051` event indicates the relays that a user will publish their `KeyPackage` Events to. The event MUST include a list of relay tags with relay URIs. These relays SHOULD be readable by anyone the user wants to be able to contact them.

```json
{
  "kind": 10051,
  "tags": [
    ["relay", "wss://inbox.nostr.wine"],
    ["relay", "wss://myrelay.nostr1.com"],
  ],
  "content": "",
  //...other fields
}
```

### Welcome Event

When a new user is added to a group via an MLS `Commit` message. The member who sends the `Commit` message to the group is responsible for sending the user being added to the group a `Welcome` Event. This `Welcome` Event is sent to the user as a [NIP-59](https://github.com/nostr-protocol/nips/blob/master/59.md) gift-wrapped event. The `Welcome` Event gives the new member the context they need to join the group and start sending messages.

Clients creating the `Welcome` Event MUST wait until they have received acknowledgement from relays that their `Group` Event with the `Commit` has been received before publishing the `Welcome` Event.

```json
{
   "id": <id>,
   "kind": 444,
   "created_at": <unix timestamp in seconds>,
   "pubkey": <nostr identity pubkey of sender>,
   "content": <serialized Welcome object>,
   "tags": [
      ["e", <ID of the KeyPackage Event used to add the user to the group>],
      ["relays", <array of relay urls>],
   ],
   "sig": <NOT SIGNED>
}
```

- The `content` field is required and is a hex-encded, serialized `MLSMessage` object containing the MLS `Welcome` object.
- The `e` tag is required and is the ID of the KeyPackage Event used to add the user to the group.
- The `relays` tag is required and is a list of relays clients should query for Group Events.

`Welcome` Events are then sealed and gift-wrapped as detailed in [NIP-59](https://github.com/nostr-protocol/nips/blob/master/59.md) before being published. Like all events that are sealed and gift-wrapped, `kind: 444` events MUST never be signed. This ensures that if they were ever leaked they would not be publishable to relays.

> #### Large Groups
>
> For groups above ~150 participants, welcome messages will become larger than is permitted by many Nostr relays. There is currently work underway on the MLS protocol to support "light" client `Welcome` objects that don't require the full Ratchet Tree state to be sent to the new member. This section will be updated with recommendations for how to handle large groups.

## Group Events

`Group` Events are all the messages that are sent within a group. This includes all "control" events that update the shared group state over time (`Proposal`, `Commit`) and messages sent between members of the group (`Application` messages).

`Group` Events are published using an ephemeral Nostr keypair to obfuscate the number and identity of group participants. Clients MUST use a new Nostr keypair for each `Group` Event they publish.

```json
{
   "id": <id>,
   "kind": 445,
   "created_at": <unix timestamp in seconds>,
   "pubkey": <ephemeral sender pubkey>,
   "content": <NIP-44 encrypted serialized MLSMessage object>,
   "tags": [
      ["h", <group id>]
   ],
   "sig": <signed with ephemeral sender key>
}
```
- The `content` field is a serialized [`MLSMessage`](https://www.rfc-editor.org/rfc/rfc9420.html#section-6-4) object which is then encrypted according to [NIP-44](44.md). However, instead of using the sender and receivers keys to derive a `conversation_key`, the NIP-44 encryption is done using a Nostr keypair generated from the MLS [`exporter_secret`](https://www.rfc-editor.org/rfc/rfc9420.html#section-8.5) to calulate the `conversation_key` value. Essentially, you use the hex-encoded `exporter_secret` value as the private key (used as the sender key), calculate the public key for that private key (used as the receiver key), and then proceed with the standard NIP-44 scheme to encrypt and decrypt messages.
- The `exporter_secret` value should be generated with a 32-byte length and labeled `nostr`. This `exporter_secret` value is rotated on each new epoch in the group. Clients should generate a new 32-byte value each time they process a valid `Commit` message.
- The `pubkey` is the hex-encoded public key of the ephemeral sender.
- The `h` tag is the nostr group ID value (from the Nostr Group Data Extension).

### `Proposal` and `Commit` Messages

`Proposal` messages are a special type of message that proposes a change to a group, while `Commit` messages are messages that commit the group to a change in the state of the group.

`Proposal` messages can be created and sent by any member of a group. These `Proposal` messages are stored and can be reviewed for inclusion in the next `Commit` message.

`Commit` messages MUST only be sent and processed when the creator of the `Commit` message, identified by their Leaf Node credential, is among those listed in the `admin_pubkeys` field of the [nostr_group_data](02.md) extension.

Clients MUST verify that the sender of a `Commit` is in the current list of admins before processing a `Commit`.

### `Application` Messages

`Application` messages are the messages that are sent within the group by members. These are contained within the `MLSMessage` object. The format of these messages should be unsigned Nostr events of the appropriate kind. For normal DM or group messages, clents SHOULD use `kind: 9` chat message events. If the user reacts to a message, it would be a `kind: 7` event, and so on.

This means that once the `Application` message has been decrypted and deserialized, clients can store those events and treat them as any other Nostr event, effectively creating a private Nostr feed of the group's activity and taking advantage of all the features of Nostr.

These inner unsigned Nostr events MUST use the member's Nostr identity key for the `pubkey` field and clients MUST check that the identity of the member who sent the message matches the pubkey of the inner Nostr event.

These Nostr events MUST remain **unsigned** to ensure that if they were to leak to relays they would not be published publicly. These Nostr events MUST not include any "h" tags or other tags that would identify the group that they belong to.

### `Commit` Message race conditions

The MLS protocol is resilient to almost all messages arriving out of order. However, the order of `Commit` messages is important for the group state to move forward from one epoch to the next correctly. Given Nostr's nature as a decentralized network, it is possible for a client to receive 2 or more `Commit` messages all attempting to update to a new epoch at the same time.

Clients sending `Commit` messages MUST wait until they receive acknowledgement from at least one relay that their Group Message Event with the `Commit` has been received before applying the commit to their own group state.

If a client receives 2 or more `Commit` messages attempting to change same epoch, they MUST apply only one of the `Commit` messages they receive, determined by the following:

1. Using the `created_at` timestamp on the kind `445` event. The `Commit` with the lowest value for `created_at` is the message to be applied. The other `Commit` message is discarded.
2. If the `created_at` timestamp is the same for two or more `Commit` messages, the `Commit` message with the lowest value (lexicographically) for `id` field is the message to be applied.

Clients SHOULD retain previous group state for a short period of time in order to recover from forked group state.
