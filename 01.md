# MIP-01

## Group Construction & Marmot Group Data Extension

`review` `mandatory`

This document defines how to create and configure MLS groups with Nostr integration, including the mandatory Marmot Group Data Extension. This is one of the core specifications that MUST be implemented by all projects wanting to be interoperable.

## Creating Groups

### Group Identity and Privacy

Every MLS group has a unique 32-byte ID (distinct from the `nostr_group_id` field of the Marmot Group Data Extension detailed below) that serves as its permanent identifier. This ID is:
- **Private**: Never published to relays in any form
- **Permanent**: Cannot be changed once the group is created
- **Random**: Generated using secure randomness

### Compatibility Requirements

Before creating a group, clients must verify compatibility with intended members by checking their published `KeyPackage` events. This ensures all members support the same:
- **Ciphersuite**: Cryptographic algorithms used for the group
- **Capabilities**: MLS features the group will use
- **Extensions**: Additional functionality required by the group

### Required MLS Extensions

All groups MUST include these MLS extensions:

- [`required_capabilities`](https://docs.rs/openmls/latest/openmls/extensions/struct.RequiredCapabilitiesExtension.html) - Defines what MLS features all members must support
- [`ratchet_tree`](https://docs.rs/openmls/latest/openmls/extensions/struct.RatchetTreeExtension.html) - Manages the cryptographic key tree structure
- [`marmot_group_data`](#marmot-group-data-extension) - Links MLS groups to Marmot-specific data

### Group State Changes

Group modifications follow a two-step process:

1. **Proposal**: Any member can propose changes (add/remove members, update settings)
2. **Commit**: An admin commits to a set of proposals, making them official

While these are MLS operations, `Commit` events must be published to Nostr relays so all members can see and process the changes.

## Marmot Group Data Extension

The `marmot_group_data` extension brings Marmot protocol specific data into authenticated and cryptographically verified MLS group state. This extension:

- **Is mandatory**: MUST be included in all groups
- **Is cryptographically secure**: Changes are authenticated and tamper-proof
- **Stores Nostr metadata**: Contains information like group admins and Nostr-specific settings

This extension MUST be included as a required capability when creating any new group.

### Extension Identifier

This extension uses the identifier `0xF2EE`. Implementations MUST use this identifier when registering support for this extension in MLS capabilities negotiation.

### Purpose and Use Cases

The Marmot Group Data Extension serves several critical functions:

1. **Group Identity Mapping**: Links MLS group encryption with Nostr's decentralized identity system
2. **Relay Agreement**: Provides authenticated relay endpoints for group message distribution
3. **Access Control**: Establishes cryptographically verified admin roles independent of MLS protocol roles
4. **Group Avatar Encryption**: Enables secure, encrypted sharing of the group's avatar image with ChaCha20-Poly1305 and optional cleanup of old images via deterministic upload identity derivation
5. **Metadata Protection**: Ensures group metadata changes are authenticated and verifiable by all members

### TLS Serialization Requirements

**CRITICAL**: This extension MUST use TLS presentation language serialization ([RFC 8446 Section 3](https://www.rfc-editor.org/rfc/rfc8446.html#section-3)) with proper length prefixes and byte alignment. Incorrect TLS serialization will cause interoperability failures.

### Extension Fields

#### Field Specifications

| Field            | TLS Type                                | Length Constraints | Description |
| ---------------- | --------------------------------------- | ------------------ | ----------- |
| `version`        | `uint16 version`                       | Exactly 2 bytes    | Extension format version number. Current version is `1`. Implementations MUST validate version compatibility before processing extension data. |
| `nostr_group_id` | `opaque nostr_group_id[32]`            | Exactly 32 bytes   | A 32-byte identifier for the group used in Nostr protocol operations. This value is distinct from the MLS group ID and MAY be updated over time through group proposals. This identifier is used in the `h` tags when publishing group message events to Nostr relays. MUST be cryptographically random when initially generated. |
| `name`           | `opaque name<0..2^16-1>`               | 0-65535 bytes      | UTF-8 encoded group name. MUST be valid UTF-8. SHOULD be limited to 255 characters for practical display purposes. Empty string is permitted for unnamed groups. |
| `description`    | `opaque description<0..2^16-1>`        | 0-65535 bytes      | UTF-8 encoded group description. MUST be valid UTF-8. SHOULD be limited to 1000 characters for practical display purposes. Empty string is permitted. |
| `admin_pubkeys`  | `opaque admin_pubkeys<0..2^16-1>`      | 0-65535 bytes      | Array of 32-byte Nostr public keys (hex-encoded as 64-character strings, then UTF-8 encoded). Each public key MUST be a valid secp256k1 public key. Clients MUST verify admin status before processing proposals that modify group state, membership, or metadata. The array MUST NOT contain duplicate keys. At least one admin key MUST be present for most group operations. |
| `relays`         | `opaque relays<0..2^16-1>`             | 0-65535 bytes      | Array of UTF-8 encoded WebSocket URLs for Nostr relays. Each URL MUST be a valid WebSocket URI (ws:// or wss://). URLs MUST be properly validated before use. The array SHOULD contain at least one relay URL and SHOULD NOT exceed 20 relays for practical performance. |
| `image_hash`     | `opaque image_hash[32]`                | Exactly 32 bytes   | SHA-256 hash of the encrypted group avatar image stored via [Blossom](https://github.com/hzrd149/blossom/tree/master) protocol. The hash identifies the encrypted blob on the storage server. May be all zeros if no image is set. |
| `image_key`      | `opaque image_key[32]`                 | Exactly 32 bytes   | ChaCha20-Poly1305 encryption key for the group's avatar image. MUST be cryptographically random when generated. Also serves as the seed for deriving the Nostr keypair used for Blossom upload authentication (see [Image Upload Identity](#image-upload-identity)). May be all zeros if no image is set. |
| `image_nonce`    | `opaque image_nonce[12]`               | Exactly 12 bytes   | ChaCha20-Poly1305 nonce for avatar image encryption. MUST be cryptographically random and unique for each image. Used with `image_key` for authenticated encryption/decryption. May be all zeros if no image is set. |

#### TLS Structure Definition

In TLS presentation language, the extension data MUST be structured as:

```tls
struct {
    uint16 version;                    // Version number (current: 1)
    opaque nostr_group_id[32];
    opaque name<0..2^16-1>;
    opaque description<0..2^16-1>;
    opaque admin_pubkeys<0..2^16-1>;
    opaque relays<0..2^16-1>;
    opaque image_hash[32];
    opaque image_key[32];
    opaque image_nonce[12];
} NostrGroupData;
```

#### Version Field

The `version` field enables forward-compatible evolution of the extension format:

- **Current Version**: `1` (first versioned format)
- **Future Versions**: Higher version numbers indicate newer formats with additional fields
- **Forward Compatibility**: Implementations SHOULD gracefully handle unknown versions by parsing known fields

### Implementation Considerations

#### Array Encoding Specifications

**Admin Public Keys Array**:
The `admin_pubkeys` field contains a comma-separated list of hex-encoded public keys:
- Each public key: 64 hex characters (representing 32 bytes)
- Separator: single comma character (',')
- No spaces around commas
- Example: `"03a1b2c3d4e5f6...,02f6e5d4c3b2a1..."`

**Relays Array**:
The `relays` field contains a comma-separated list of WebSocket URLs:
- Each URL: valid WebSocket URI (ws:// or wss://)
- Separator: single comma character (',')
- No spaces around commas
- Example: `"wss://relay1.example.com,wss://relay2.example.com"`

#### Image Upload Identity

The group's avatar image encryption uses ChaCha20-Poly1305 with a deterministic Nostr keypair derivation for Blossom authentication. This design enables automatic cleanup of old avatar images when updating.

**Encryption**: When encrypting a group avatar image:

```
image_key = random(32)          // Cryptographically random key
image_nonce = random(12)        // Cryptographically random nonce
encrypted_image = ChaCha20-Poly1305.encrypt(image_key, image_nonce, image_data)
```

**Upload Authentication**: The Nostr keypair for Blossom upload authentication MUST be deterministically derived from the `image_key`:

```
upload_secret = HKDF-Expand(image_key, "mip01-blossom-upload-v1", 32)
upload_keypair = secp256k1_keypair_from_secret(upload_secret)
```

This derivation provides domain separation between the encryption key and the signing key, while ensuring that anyone with the `image_key` can derive the upload keypair for cleanup purposes.

**Update and Cleanup Workflow**:

When an admin updates the group avatar:

1. **Generate new keys**: Create new random `image_key` (32 bytes) and `image_nonce` (12 bytes)
2. **Encrypt new image**: Use ChaCha20-Poly1305 to encrypt the new avatar image
3. **Derive upload keypair**: Compute `upload_secret = HKDF-Expand(new_image_key, "mip01-blossom-upload-v1", 32)` and derive the Nostr keypair
4. **Upload to Blossom**: Upload the encrypted image using the derived keypair for authentication, obtaining `new_image_hash = SHA256(encrypted_image)`
5. **Update extension**: Commit an MLS proposal updating `image_hash`, `image_key`, and `image_nonce` fields
6. **Cleanup old image**: After successful commit, derive the previous upload keypair from `old_image_key` and request deletion of the old image blob from Blossom using the derived keypair for authentication

**Security Properties**:

- **Encryption independence**: Image encryption keys persist across MLS epochs (unlike chat media in MIP-04 which uses rotating exporter secrets)
- **Cleanup capability**: Any admin who has access to a previous `image_key` can derive the upload keypair to delete that image blob
- **Domain separation**: HKDF-Expand ensures the upload secret is cryptographically independent from the encryption key
- **Forward compatibility**: Old members who leave cannot access new avatar images (they don't receive updated extension data)

#### Extension Lifecycle Management

**Creation**: When creating a new group, this extension MUST be populated with initial values and included in the group's required capabilities.

**Updates**: Any field in this extension can be updated through MLS Proposal/Commit mechanisms. All updates require admin authorization. Before processing any Commit that modifies this extension, implementations MUST verify the committer is listed in the current `admin_pubkeys` array

#### Version Handling

**Version Detection**: Implementations MUST validate the extension format version:

```pseudocode
function detect_version(extension_data) {
    if (extension_data.length < 2) {
        return ERROR_INVALID_EXTENSION
    }

    // Read version field
    version = read_uint16_be(extension_data[0:2])

    // Validate known versions
    if (version >= 1 && version <= MAX_SUPPORTED_VERSION) {
        if (validate_structure(extension_data, version)) {
            return version
        }
        return ERROR_INVALID_EXTENSION
    }

    // Handle future versions with forward compatibility
    if (version > MAX_SUPPORTED_VERSION) {
        if (validate_structure(extension_data, version)) {
            return VERSION_UNKNOWN_FUTURE
        }
    }

    return ERROR_INVALID_EXTENSION
}

function validate_structure(data, version) {
    // Minimum size: version(2) + nostr_group_id(32) + name(2+0) + desc(2+0) +
    //               admins(2+0) + relays(2+0) + image_hash(32) + image_key(32) + image_nonce(12)
    MIN_SIZE = 2 + 32 + 2 + 2 + 2 + 2 + 32 + 32 + 12  // = 118 bytes

    if (data.length < MIN_SIZE) return false

    // Validate that variable-length fields have reasonable lengths
    offset = 2 + 32  // Skip version and nostr_group_id

    // Validate name length
    name_len = read_uint16_be(data[offset:offset+2])
    if (offset + 2 + name_len > data.length) return false
    offset += 2 + name_len

    // Validate description length
    desc_len = read_uint16_be(data[offset:offset+2])
    if (offset + 2 + desc_len > data.length) return false
    offset += 2 + desc_len

    // Validate admin_pubkeys length
    admin_len = read_uint16_be(data[offset:offset+2])
    if (offset + 2 + admin_len > data.length) return false
    offset += 2 + admin_len

    // Validate relays length
    relays_len = read_uint16_be(data[offset:offset+2])
    if (offset + 2 + relays_len > data.length) return false
    offset += 2 + relays_len

    // Check remaining fixed fields fit
    REMAINING_FIXED = 32 + 32 + 12  // image_hash + image_key + image_nonce
    return (offset + REMAINING_FIXED == data.length)
}
```

**Forward Compatibility**: When encountering unknown future versions:
- Parse known fields in order (version, nostr_group_id, name, description, admin_pubkeys, relays, image_hash, image_key, image_nonce)
- Ignore additional unknown fields
- Continue normal operation with available data
- Log warning about unknown version for debugging

#### Implementation Guidelines

**Requirements**:
- Register extension `0xF2EE` as required capability
- Use exact TLS structure definition provided
- Implement version detection algorithm for forward compatibility
- Validate UTF-8 strings, public keys, and URLs
- Parse arrays as comma-separated (no spaces)
- Verify admin permissions for all extension updates including version changes

**Version-Specific Implementation**:
- **New Groups**: MUST create with version `1` format
- **Future Versions**: SHOULD implement forward compatibility for unknown versions
- **Error Handling**: MUST gracefully handle version mismatches with clear error messages

**Testing Requirements**:
- Test version detection and structure validation
- Test forward compatibility with simulated future versions
- Verify admin permission checks for version updates
- Test structure validation for malformed extension data


## Summary

This MIP defines the foundation for creating secure, Nostr-integrated groups:

### Key Components

1. **Group Creation**: Secure MLS group establishment with privacy protection
2. **Required Extensions**: Standard MLS extensions plus Nostr Group Data
3. **Marmot Group Data Extension**: Cryptographically secure bridge between MLS and Nostr
4. **Admin Controls**: Authenticated admin permissions for group management

### Implementation Requirements

**MUST implement**:
- Required MLS extensions: `required_capabilities`, `ratchet_tree`, `marmot_group_data`
- TLS serialization for Marmot Group Data Extension with versioning support
- Version detection and forward compatibility
- Admin verification for all extension updates including version changes
- Compatibility checking before group creation
- Private MLS group IDs (never publish to relays)
- ChaCha20-Poly1305 encryption for group avatar images
- Deterministic upload keypair derivation using `HKDF-Expand(image_key, "mip01-blossom-upload-v1", 32)` for Blossom authentication and cleanup
