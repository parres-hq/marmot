# MIP-01

## Group Construction & Marmot Group Data Extension

`stable` `mandatory`

This document defines how to create and configure MLS groups with Nostr integration, including the mandatory Marmot Group Data Extension. This is one of the core specifications that MUST be implemented by all projects wanting to be interoperable.

## Creating Groups

### Group Identity and Privacy

Every MLS group has a unique 32-byte ID (distinct from the `nostr_group_id` field of the Marmot Group Data Extension detailed below) that serves as its permanent identifier. This ID is:
- **Private**: Never published to relays in any form
- **Permanent**: Cannot be changed once the group is created
- **Random**: Generated using secure randomness

### Compatibility Requirements

Before creating a group, clients must verify compatibility with intended members by checking their published `KeyPackage` events. This ensures all members support the same:
- **Ciphersuite**: Cryptographic algorithms used for the group
- **Capabilities**: MLS features the group will use
- **Extensions**: Additional functionality required by the group

### Required MLS Extensions

All groups MUST include these MLS extensions:

- [`required_capabilities`](https://docs.rs/openmls/latest/openmls/extensions/struct.RequiredCapabilitiesExtension.html) - Defines what MLS features all members must support
- [`ratchet_tree`](https://docs.rs/openmls/latest/openmls/extensions/struct.RatchetTreeExtension.html) - Manages the cryptographic key tree structure
- [`marmot_group_data`](#marmot-group-data-extension) - Links MLS groups to Marmot-specific data

### Group State Changes

Group modifications follow a two-step process:

1. **Proposal**: Any member can propose changes (add/remove members, update settings)
2. **Commit**: An admin commits to a set of proposals, making them official

While these are MLS operations, `Commit` events must be published to Nostr relays so all members can see and process the changes.

## Marmot Group Data Extension

The `marmot_group_data` extension brings Marmot protocol specific data into authenticated and cryptographically verified MLS group state. This extension:

- **Is mandatory**: MUST be included in all groups
- **Is cryptographically secure**: Changes are authenticated and tamper-proof
- **Stores Nostr metadata**: Contains information like group admins and Nostr-specific settings

This extension MUST be included as a required capability when creating any new group.

### Extension Identifier

This extension uses the identifier `0xF2EE`. Implementations MUST use this identifier when registering support for this extension in MLS capabilities negotiation.

### Purpose and Use Cases

The Marmot Group Data Extension serves several critical functions:

1. **Group Identity Mapping**: Links MLS group encryption with Nostr's decentralized identity system
2. **Relay Agreement**: Provides authenticated relay endpoints for group message distribution
3. **Access Control**: Establishes cryptographically verified admin roles independent of MLS protocol roles
4. **Group Image Encryption**: Enables secure, encrypted sharing of the group's avatar image
5. **Metadata Protection**: Ensures group metadata changes are authenticated and verifiable by all members

### TLS Serialization Requirements

**CRITICAL**: This extension MUST use TLS presentation language serialization ([RFC 8446 Section 3](https://www.rfc-editor.org/rfc/rfc8446.html#section-3)) with proper length prefixes and byte alignment. Incorrect TLS serialization will cause interoperability failures.

### Extension Fields

#### Field Specifications

| Field            | TLS Type                                | Length Constraints | Description |
| ---------------- | --------------------------------------- | ------------------ | ----------- |
| `version`        | `uint16 version`                       | Exactly 2 bytes    | Extension format version number. Current version is `1`. Version `0` represents the legacy format (no version field). Implementations MUST validate version compatibility before processing extension data. |
| `nostr_group_id` | `opaque nostr_group_id[32]`            | Exactly 32 bytes   | A 32-byte identifier for the group used in Nostr protocol operations. This value is distinct from the MLS group ID and MAY be updated over time through group proposals. This identifier is used in the `h` tags when publishing group message events to Nostr relays. MUST be cryptographically random when initially generated. |
| `name`           | `opaque name<0..2^16-1>`               | 0-65535 bytes      | UTF-8 encoded group name. MUST be valid UTF-8. SHOULD be limited to 255 characters for practical display purposes. Empty string is permitted for unnamed groups. |
| `description`    | `opaque description<0..2^16-1>`        | 0-65535 bytes      | UTF-8 encoded group description. MUST be valid UTF-8. SHOULD be limited to 1000 characters for practical display purposes. Empty string is permitted. |
| `admin_pubkeys`  | `opaque admin_pubkeys<0..2^16-1>`      | 0-65535 bytes      | Array of 32-byte Nostr public keys (hex-encoded as 64-character strings, then UTF-8 encoded). Each public key MUST be a valid secp256k1 public key. Clients MUST verify admin status before processing proposals that modify group state, membership, or metadata. The array MUST NOT contain duplicate keys. At least one admin key MUST be present for most group operations. |
| `relays`         | `opaque relays<0..2^16-1>`             | 0-65535 bytes      | Array of UTF-8 encoded WebSocket URLs for Nostr relays. Each URL MUST be a valid WebSocket URI (ws:// or wss://). URLs MUST be properly validated before use. The array SHOULD contain at least one relay URL and SHOULD NOT exceed 20 relays for practical performance. |
| `image_hash`     | `opaque image_hash[32]`                | Exactly 32 bytes   | SHA-256 hash identifying the group's display image stored via [Blossom](https://github.com/hzrd149/blossom/tree/master) protocol. The hash MUST correspond to the actual image content for integrity verification. May be all zeros if no image is set. |
| `image_key`      | `opaque image_key[32]`                 | Exactly 32 bytes   | AES-256-GCM encryption key for the group's image. MUST be cryptographically random. Used in conjunction with `image_nonce` for authenticated encryption. May be all zeros if no image encryption is needed. |
| `image_nonce`    | `opaque image_nonce[12]`               | Exactly 12 bytes   | AES-256-GCM nonce for image encryption. MUST be unique for each encrypted image. Used with `image_key` for authenticated encryption/decryption operations. May be all zeros if no image encryption is needed. |

#### TLS Structure Definition

In TLS presentation language, the extension data MUST be structured as:

```tls
struct {
    uint16 version;                    // Version number (current: 1)
    opaque nostr_group_id[32];
    opaque name<0..2^16-1>;
    opaque description<0..2^16-1>;
    opaque admin_pubkeys<0..2^16-1>;
    opaque relays<0..2^16-1>;
    opaque image_hash[32];
    opaque image_key[32];
    opaque image_nonce[12];
} NostrGroupData;
```

#### Version Field

The `version` field enables forward-compatible evolution of the extension format:

- **Current Version**: `1` (first versioned format)
- **Legacy Format**: Data without version field is treated as version `0`
- **Future Versions**: Higher version numbers indicate newer formats with additional fields
- **Backward Compatibility**: Implementations MUST support reading legacy (version 0) format
- **Forward Compatibility**: Implementations SHOULD gracefully handle unknown versions by parsing known fields

### Implementation Considerations

#### Array Encoding Specifications

**Admin Public Keys Array**:
The `admin_pubkeys` field contains a comma-separated list of hex-encoded public keys:
- Each public key: 64 hex characters (representing 32 bytes)
- Separator: single comma character (',')
- No spaces around commas
- Example: `"03a1b2c3d4e5f6...,02f6e5d4c3b2a1..."`

**Relays Array**:
The `relays` field contains a comma-separated list of WebSocket URLs:
- Each URL: valid WebSocket URI (ws:// or wss://)
- Separator: single comma character (',')
- No spaces around commas
- Example: `"wss://relay1.example.com,wss://relay2.example.com"`

#### Extension Lifecycle Management

**Creation**: When creating a new group, this extension MUST be populated with initial values and included in the group's required capabilities. New groups MUST use version `1` format.

**Updates**: Any field in this extension can be updated through MLS Proposal/Commit mechanisms. All updates require admin authorization. Before processing any Commit that modifies this extension, implementations MUST verify the committer is listed in the current `admin_pubkeys` array

#### Version Handling and Migration

**Version Detection**: Implementations MUST detect the extension format version using this algorithm to avoid collision with random `nostr_group_id` bytes:

```pseudocode
function detect_version(extension_data) {
    if (extension_data.length < 2) {
        return ERROR_INVALID_EXTENSION
    }

    // Read potential version field
    potential_version = read_uint16_be(extension_data[0:2])

    // If it claims to be a known version, validate the structure
    if (potential_version >= 1 && potential_version <= MAX_SUPPORTED_VERSION) {
        if (validate_versioned_structure(extension_data, potential_version)) {
            return potential_version
        }
        // Structure validation failed, might be legacy with coincidental bytes
    }

    // Try parsing as legacy format
    if (validate_legacy_structure(extension_data)) {
        return VERSION_LEGACY
    }

    // If potential_version > MAX_SUPPORTED_VERSION, attempt forward compatibility
    if (potential_version > MAX_SUPPORTED_VERSION) {
        if (validate_versioned_structure(extension_data, potential_version)) {
            return VERSION_UNKNOWN_FUTURE
        }
    }

    return ERROR_INVALID_EXTENSION
}

function validate_versioned_structure(data, version) {
    // Minimum size: version(2) + nostr_group_id(32) + name(2+0) + desc(2+0) +
    //               admins(2+0) + relays(2+0) + image_hash(32) + image_key(32) + image_nonce(12)
    MIN_SIZE = 2 + 32 + 2 + 2 + 2 + 2 + 32 + 32 + 12  // = 118 bytes

    if (data.length < MIN_SIZE) return false

    // Validate that variable-length fields have reasonable lengths
    offset = 2 + 32  // Skip version and nostr_group_id

    // Validate name length
    name_len = read_uint16_be(data[offset:offset+2])
    if (offset + 2 + name_len > data.length) return false
    offset += 2 + name_len

    // Validate description length
    desc_len = read_uint16_be(data[offset:offset+2])
    if (offset + 2 + desc_len > data.length) return false
    offset += 2 + desc_len

    // Validate admin_pubkeys length
    admin_len = read_uint16_be(data[offset:offset+2])
    if (offset + 2 + admin_len > data.length) return false
    offset += 2 + admin_len

    // Validate relays length
    relays_len = read_uint16_be(data[offset:offset+2])
    if (offset + 2 + relays_len > data.length) return false
    offset += 2 + relays_len

    // Check remaining fixed fields fit
    REMAINING_FIXED = 32 + 32 + 12  // image_hash + image_key + image_nonce
    return (offset + REMAINING_FIXED == data.length)
}

function validate_legacy_structure(data) {
    // Legacy format: nostr_group_id(32) + name(2+len) + desc(2+len) +
    //                admins(2+len) + relays(2+len) + image_hash(32) + image_key(32) + image_nonce(12)
    MIN_SIZE = 32 + 2 + 2 + 2 + 2 + 32 + 32 + 12  // = 114 bytes minimum

    if (data.length < MIN_SIZE) return false

    offset = 32  // Skip nostr_group_id

    // Validate variable-length fields same as versioned format
    // ... (same validation logic as above)

    return (offset + REMAINING_FIXED == data.length)
}
```

**Legacy Format Support**: Implementations MUST support reading legacy (version 0) format indefinitely. Legacy format detection:
- No version field present
- Data starts directly with `nostr_group_id[32]`
- Structure validation confirms it parses correctly as legacy format

**Critical Note**: Simple version field checking is insufficient because the first 2 bytes of a legacy `nostr_group_id` could coincidentally match a valid version number. The structure validation approach prevents misinterpretation of legacy data as versioned format.

**Version Migration**: Groups can migrate from legacy format to version 1 through admin-initiated Proposal/Commit:

1. **Prerequisites**: All group members MUST support version 1 format
2. **Migration Process**: Admin creates Proposal to update extension with version field set to `1`
3. **Backward Compatibility**: After migration, legacy clients will be unable to process group updates
4. **Rollback**: Not supported - migration is one-way

**Forward Compatibility**: When encountering unknown future versions:
- Parse known fields in order (version, nostr_group_id, name, description, admin_pubkeys, relays, image_hash, image_key, image_nonce)
- Ignore additional unknown fields
- Continue normal operation with available data
- Log warning about unknown version for debugging

#### Implementation Guidelines

**Requirements**:
- Register extension `0xF2EE` as required capability
- Use exact TLS structure definition provided (version 1 for new groups)
- Implement version detection algorithm for backward/forward compatibility
- Validate UTF-8 strings, public keys, and URLs
- Parse arrays as comma-separated (no spaces)
- Verify admin permissions for all extension updates including version changes

**Version-Specific Implementation**:
- **New Groups**: MUST create with version `1` format
- **Legacy Support**: MUST support reading version `0` (legacy) format indefinitely
- **Migration**: MUST implement admin-controlled migration from legacy to version `1`
- **Future Versions**: SHOULD implement forward compatibility for unknown versions
- **Error Handling**: MUST gracefully handle version mismatches with clear error messages

**Testing Requirements**:
- Test reading both legacy and version `1` formats
- Test version detection with `nostr_group_id` values that start with version-like bytes (collision testing)
- Test migration process from legacy to version `1`
- Test forward compatibility with simulated future versions
- Verify admin permission checks for version updates
- Test structure validation for malformed extension data

#### Migration Strategy for Existing Deployments

For controlled deployments with few existing groups, the following migration strategy is recommended:

**Phase 1: Client Updates (Backward Compatible)**
1. Deploy client updates that support both legacy and version `1` formats
2. New groups automatically use version `1` format
3. Existing groups continue using legacy format
4. Verify all clients can read both formats

**Phase 2: Group Migration (Admin-Controlled)**
1. Identify groups to migrate (typically all active groups)
2. For each group, admin initiates migration:
   ```
   - Create Proposal to update Marmot Group Data Extension
   - Set version field to 1, preserve all other data
   - Commit the proposal through normal MLS flow
   ```
3. Verify successful migration and group functionality
4. Monitor for any compatibility issues

**Phase 3: Legacy Deprecation (Optional)**
1. After sufficient time (e.g., 6+ months), consider deprecating legacy format support
2. Add warnings for groups still using legacy format
3. Eventually remove legacy format support in future major version

**Migration Tooling**:
Implementations SHOULD provide administrative tools to:
- List groups by extension version
- Batch migrate multiple groups
- Verify migration success
- Rollback failed migrations (by recreating group if necessary)

## Summary

This MIP defines the foundation for creating secure, Nostr-integrated groups:

### Key Components

1. **Group Creation**: Secure MLS group establishment with privacy protection
2. **Required Extensions**: Standard MLS extensions plus Nostr Group Data
3. **Marmot Group Data Extension**: Cryptographically secure bridge between MLS and Nostr
4. **Admin Controls**: Authenticated admin permissions for group management

### Implementation Requirements

**MUST implement**:
- Required MLS extensions: `required_capabilities`, `ratchet_tree`, `marmot_group_data`
- TLS serialization for Marmot Group Data Extension with versioning support
- Version detection and backward compatibility with legacy format
- Admin verification for all extension updates including version changes
- Compatibility checking before group creation
- Private MLS group IDs (never publish to relays)
