# MIP-04

## Encrypted Media

`draft` `optional`

This document defines how to securely share media files (images, videos, audio, documents) within Marmot groups while maintaining end-to-end encryption and privacy guarantees.

This is different to the way in which group avatar images are encrypted and shared among group members via the `marmot_group_data` extension detailed in [MIP-01](01.md).

## Overview

Encrypted media enables secure sharing of files within Marmot groups by:

1. **Encrypting files** using keys derived from MLS exporter secrets
2. **Storing encrypted blobs** on content-addressed storage systems (like Blossom)
3. **Sharing metadata** through `imeta` tags in Group Messages

## Versioning

This specification uses a versioning system to enable future evolution of the encrypted media format while maintaining backward compatibility. The version is communicated through the `v` field in `imeta` tags, which clients use to determine the appropriate decryption method.

**Current Version**: The specification is currently at version `1`, which defines deterministic ChaCha20-Poly1305 AEAD encryption with keys derived from MLS exporter secrets. All `imeta` tags MUST include `v 1` to indicate this encryption version.

**Future Versions**: Higher version numbers will indicate newer encryption schemes, potentially supporting features like chunked encryption, streaming decryption, or alternative cipher suites. Clients MUST verify version compatibility before attempting decryption and SHOULD gracefully handle unknown versions by displaying appropriate error messages.

**Domain Separation**: Version 1 includes the scheme label `"mip04-v1"` in all cryptographic contexts (key derivation and AAD construction) to provide domain separation and prevent cross-version collisions. This ensures that keys and encrypted content from different versions cannot be confused or misused, enabling safe future upgrades.

## Media Encryption Process

### Key Derivation

Version 1 uses deterministic key and nonce derivation using the current epoch's MLS group exporter secret:

```
exporter_secret = MLS-Exporter("nostr", "nostr", 32)
file_key = HKDF-Expand(exporter_secret, "mip04-v1" || 0x00 || file_hash_bytes || 0x00 || mime_type_bytes || 0x00 || filename_bytes || 0x00 || "key", 32)
nonce = HKDF-Expand(exporter_secret, "mip04-v1" || 0x00 || file_hash_bytes || 0x00 || mime_type_bytes || 0x00 || filename_bytes || 0x00 || "nonce", 12)
```

Where the context components are constructed with exact byte layout for cross-implementation compatibility:

```
"mip04-v1" = scheme label as UTF-8 bytes for domain separation
file_hash_bytes = SHA256(original_file_content) as 32 raw bytes
mime_type_bytes = MIME type in canonical form as UTF-8 (e.g., "image/jpeg")
filename_bytes = original filename as UTF-8 bytes (e.g., "document.pdf")
0x00 = single null byte separator between components
```

**MIME Type Canonicalization**: MIME types MUST be canonicalized before use in cryptographic operations:
- Convert to lowercase (e.g., "IMAGE/JPEG" → "image/jpeg")
- Trim leading and trailing whitespace
- Use standard MIME type format without parameters (e.g., "image/jpeg; charset=utf-8" → "image/jpeg")
- Apply any registered MIME type aliases to their canonical forms

This ensures consistent key derivation across implementations regardless of input formatting.

**Filename Inclusion**: The filename is included in both key and nonce derivation to prevent cryptographic nonce reuse when the same file content is encrypted multiple times with different filenames. This ensures that each (content, filename) pair produces unique encryption keys and nonces, maintaining ChaCha20-Poly1305 security requirements.

### Encryption Algorithm

Version 1 uses ChaCha20-Poly1305 AEAD encryption with associated data for tamper protection:

```
aad = "mip04-v1" || 0x00 || file_hash_bytes || 0x00 || mime_type_bytes || 0x00 || filename_bytes
encrypted_content = ChaCha20-Poly1305.encrypt(file_key, nonce, plaintext, aad)
```

The associated data (AAD) binds the scheme version, file hash, MIME type, and filename to prevent metadata tampering and provide domain separation.

## Storage Integration

### Content-Addressed Storage

Encrypted media files can be stored on any content-addressed storage system where files are identified by their hash. The general process is:

1. **Encrypt** the original file using the process above
2. **Upload** the encrypted blob to the storage system
3. **Address** the blob using `SHA256(encrypted_content)` as the identifier
4. **Store** the storage URL and metadata in `imeta` tags

The storage identifier (hash of encrypted content) can be used as:
- A filename in traditional file systems
- A content address in distributed storage systems
- A blob identifier in cloud storage services
- Any other hash-based addressing scheme

### Blossom Protocol (Reference Implementation)

This specification focuses on the [Blossom protocol](https://github.com/hzrd149/blossom) as the primary storage backend, which provides:

- **Content-addressed storage** using SHA256 hashes
- **Nostr-based authentication** for uploads and deletions
- **HTTP-based API** for simple integration
- **Deduplication** through hash-based addressing

### Privacy Properties

Content-addressed storage with encryption provides strong privacy guarantees:

- **Storage addresses** are hashes of encrypted content (essentially random)
- **No correlation** possible between original files and storage addresses
- **Group privacy** is the primary boundary - only group members can decrypt content
- **Forward secrecy** follows standard MLS behavior - new members cannot decrypt historical media

## `imeta` Tag Format

Media metadata is shared in chat messages through [NIP-92](https://github.com/nostr-protocol/nips/blob/master/92.md) compliant `imeta` tags within Group Messages:

```
imeta url <blossom_url> m <mime_type> filename <filename> [dim <dimensions>] [blurhash <hash>] x <file_sha256> v <version>
```

### Field Specifications

| Field | Description | Required |
|-------|-------------|----------|
| `url` | Blossom storage URL for the encrypted blob | Yes |
| `m` | MIME type in canonical form as UTF-8 (e.g., "image/jpeg") | Yes |
| `filename` | Original filename for display | Yes |
| `dim` | Image/video dimensions as "widthxheight" | Optional |
| `blurhash` | BlurHash for progressive loading | Optional |
| `x` | SHA256 hash of original file content (hex-encoded) | Yes |
| `v` | Encryption version number (currently "1") | Yes |

### Integrity Verification

The `x` field contains the SHA256 hash of the original file content and serves as an integrity check. After downloading and decrypting a file, clients MUST verify:

```
SHA256(decrypted_content) == x_field_value
```

This ensures the decryption was successful and the file was not corrupted.



## Processing Flow

**Sending Media**:
1. **Sanitize** file (remove EXIF, GPS, etc.)
2. **Hash** original content for integrity verification
3. **Derive keys** from current MLS exporter secret
4. **Encrypt** file with AEAD including metadata binding
5. **Upload** encrypted blob to Blossom storage
6. **Create `imeta`** tags with metadata and storage URL
7. **Send** Group Message containing `imeta` tags

**Receiving Media**:
1. **Parse `imeta`** tags from Group Message
2. **Download** encrypted blob from storage URL
3. **Derive keys** using file hash and metadata from `imeta`
4. **Decrypt** blob with AEAD verification
5. **Verify integrity** by checking SHA256 matches `x` field
6. **Display** and/or save decrypted content

### Security Requirements

**MUST implement**:
- Exact byte layout for context construction (cross-implementation compatibility)
- AEAD associated data binding to prevent metadata tampering
- Integrity verification using `x` field after decryption
- Proper HKDF key derivation from MLS exporter secrets
- Version-based encryption scheme for future upgrades

**MUST verify**:
- AAD matches `imeta` fields before accepting decrypted content
- File hash integrity after decryption
- MIME type consistency between `imeta` and actual content
- Version compatibility before attempting decryption

## Scope and Limitations

### Version 1 Scope

This specification supports **single-blob objects only**. Each media file is encrypted and stored as a single atomic unit. Size and timeout limits remain a library/application-level concern.

### Out of Scope

The following features are explicitly **out of scope** for Version 1:

- **Chunked encryption** for large files
- **Streaming decryption** for progressive loading
- **Multi-part uploads** with per-chunk keys
- **Cross-group deduplication** (security boundary is the MLS group)

Future versions may address these features, but the base specification focuses on the simpler single-blob case.

## Security Considerations

### Threat Model

This specification protects against:

1. **Storage provider compromise** - Encrypted blobs reveal no information about content
2. **Network surveillance** - All content and metadata are encrypted
3. **Metadata tampering** - AEAD associated data prevents modification
4. **File corruption** - Integrity verification detects corruption

### Security Properties

1. **Confidentiality**: Only current group members can decrypt media
2. **Integrity**: Tampering with encrypted blobs or metadata is detectable
3. **Authenticity**: Media origin is verifiable through MLS group membership
4. **Forward Secrecy**: Historical media becomes inaccessible after MLS epoch changes
5. **Post-Compromise Security**: Future media remains secure after key recovery
6. **Nonce Uniqueness**: Including filename in key/nonce derivation prevents dangerous nonce reuse scenarios that could compromise ChaCha20-Poly1305 security when the same file content is encrypted with different filenames
