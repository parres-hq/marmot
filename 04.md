# MIP-04

## Encrypted Media

`draft` `optional`

This document defines how to securely share media files (images, videos, audio, documents) within Marmot groups while maintaining end-to-end encryption and privacy guarantees.

This is different to the way in which group avatar images are encrypted and shared among group members via the `marmot_group_data` extension detailed in [MIP-01](01.md).

## Overview

Encrypted media enables secure sharing of files within Marmot groups by:

1. **Encrypting files** using keys derived from MLS exporter secrets
2. **Storing encrypted blobs** on content-addressed storage systems (like Blossom)
3. **Sharing metadata** through IMETA tags in Group Messages

## Media Encryption Process

### Key Derivation

Media encryption keys are derived from the current epoch's MLS group exporter secret:

```
exporter_secret = MLS-Exporter("nostr", "nostr", 32)
file_key = HKDF-Expand(exporter_secret, file_hash_bytes || 0x00 || mime_type_bytes || 0x00 || "key", 32)
nonce = HKDF-Expand(exporter_secret, file_hash_bytes || 0x00 || mime_type_bytes || 0x00 || "nonce", 12)
```

Where the context components are constructed with exact byte layout for cross-implementation compatibility:

```
file_hash_bytes = SHA256(original_file_content) as 32 raw bytes
mime_type_bytes = MIME type in lowercase UTF-8 (e.g., "image/jpeg")
0x00 = single null byte separator between components
```

### Deterministic Encryption

Version 1 uses deterministic key and nonce derivation. This has a side benefit of enabling content deduplication within the same MLS epoch.

**Important**: Ciphertext equality only holds within a single MLS epoch. Deduplication is an incidental benefit, not a security guarantee.

### Encryption Algorithm

Version 1 uses ChaCha20-Poly1305 AEAD encryption with associated data for tamper protection:

```
aad = file_hash_bytes || 0x00 || mime_type_bytes || 0x00 || filename_bytes
encrypted_content = ChaCha20-Poly1305.encrypt(file_key, nonce, plaintext, aad)
```

The associated data (AAD) binds the file hash, MIME type, and filename to prevent metadata tampering.

## Storage Integration

### Content-Addressed Storage

Encrypted media files can be stored on any content-addressed storage system where files are identified by their hash. The general process is:

1. **Encrypt** the original file using the process above
2. **Upload** the encrypted blob to the storage system
3. **Address** the blob using `SHA256(encrypted_content)` as the identifier
4. **Store** the storage URL and metadata in IMETA tags

The storage identifier (hash of encrypted content) can be used as:
- A filename in traditional file systems
- A content address in distributed storage systems
- A blob identifier in cloud storage services
- Any other hash-based addressing scheme

### Blossom Protocol (Reference Implementation)

This specification focuses on the [Blossom protocol](https://github.com/hzrd149/blossom) as the primary storage backend, which provides:

- **Content-addressed storage** using SHA256 hashes
- **Nostr-based authentication** for uploads and deletions
- **HTTP-based API** for simple integration
- **Deduplication** through hash-based addressing

### Privacy Properties

Content-addressed storage with encryption provides strong privacy guarantees:

- **Storage addresses** are hashes of encrypted content (essentially random)
- **No correlation** possible between original files and storage addresses
- **Group privacy** is the primary boundary - only group members can decrypt content
- **Forward secrecy** follows standard MLS behavior - new members cannot decrypt historical media

## IMETA Tag Format

Media metadata is shared through [NIP-92](https://github.com/nostr-protocol/nips/blob/master/92.md) compliant IMETA tags within Group Messages:

```
imeta url <blossom_url> m <mime_type> filename <filename> [dim <dimensions>] [blurhash <hash>] x <file_sha256> v <version>
```

### Field Specifications

| Field | Description | Required |
|-------|-------------|----------|
| `url` | Blossom storage URL for the encrypted blob | Yes |
| `m` | MIME type in lowercase (e.g., "image/jpeg") | Yes |
| `filename` | Original filename for display | Yes |
| `dim` | Image/video dimensions as "widthxheight" | Optional |
| `blurhash` | BlurHash for progressive loading | Optional |
| `x` | SHA256 hash of original file content (hex-encoded) | Yes |
| `v` | Encryption version number (currently "1") | Yes |

### Integrity Verification

The `x` field contains the SHA256 hash of the original file content and serves as an integrity check. After downloading and decrypting a file, clients MUST verify:

```
SHA256(decrypted_content) == x_field_value
```

This ensures the decryption was successful and the file was not corrupted.

## Implementation Requirements

### Version 1 Decryption

```rust
pub fn decrypt_media_v1(
    encrypted_data: &[u8],
    mls_group: &MlsGroup,
    file_hash_bytes: &[u8; 32], // Raw SHA256 bytes from x field
    mime_type: &str,
    filename: &str,
) -> Result<Vec<u8>> {
    let exporter_secret = mls_group.export_secret("nostr", b"nostr", 32)?;

    // Build file key context: file_hash_bytes || 0x00 || mime_type_bytes || 0x00 || "key"
    let mut file_key_context = Vec::with_capacity(32 + 1 + mime_type.len() + 1 + 3);
    file_key_context.extend_from_slice(file_hash_bytes);
    file_key_context.push(0x00);
    file_key_context.extend_from_slice(mime_type.to_lowercase().as_bytes());
    file_key_context.push(0x00);
    file_key_context.extend_from_slice(b"key");
    let file_key = hkdf_expand(&exporter_secret, &file_key_context, 32)?;

    // Build nonce context: file_hash_bytes || 0x00 || mime_type_bytes || 0x00 || "nonce"
    let mut nonce_context = Vec::with_capacity(32 + 1 + mime_type.len() + 1 + 5);
    nonce_context.extend_from_slice(file_hash_bytes);
    nonce_context.push(0x00);
    nonce_context.extend_from_slice(mime_type.to_lowercase().as_bytes());
    nonce_context.push(0x00);
    nonce_context.extend_from_slice(b"nonce");
    let nonce = hkdf_expand(&exporter_secret, &nonce_context, 12)?;

    // Build associated data for tamper protection
    let mut aad = Vec::with_capacity(32 + 1 + mime_type.len() + 1 + filename.len());
    aad.extend_from_slice(file_hash_bytes);
    aad.push(0x00);
    aad.extend_from_slice(mime_type.to_lowercase().as_bytes());
    aad.push(0x00);
    aad.extend_from_slice(filename.as_bytes());

    decrypt_chacha20poly1305_aead(encrypted_data, &file_key, &nonce, &aad)
}
```

### Processing Flow

**Sending Media**:
1. **Sanitize** file (remove EXIF, GPS, etc.)
2. **Hash** original content for integrity verification
3. **Derive keys** from current MLS exporter secret
4. **Encrypt** file with AEAD including metadata binding
5. **Upload** encrypted blob to Blossom storage
6. **Create IMETA** tags with metadata and storage URL
7. **Send** Group Message containing IMETA tags

**Receiving Media**:
1. **Parse IMETA** tags from Group Message
2. **Download** encrypted blob from storage URL
3. **Derive keys** using file hash and metadata from IMETA
4. **Decrypt** blob with AEAD verification
5. **Verify integrity** by checking SHA256 matches `x` field
6. **Display** and/or save decrypted content

### Security Requirements

**MUST implement**:
- Exact byte layout for context construction (cross-implementation compatibility)
- AEAD associated data binding to prevent metadata tampering
- Integrity verification using `x` field after decryption
- Proper HKDF key derivation from MLS exporter secrets
- Version-based encryption scheme for future upgrades

**MUST verify**:
- AAD matches IMETA fields before accepting decrypted content
- File hash integrity after decryption
- MIME type consistency between IMETA and actual content
- Version compatibility before attempting decryption

## Scope and Limitations

### Version 1 Scope

This specification supports **single-blob objects only**. Each media file is encrypted and stored as a single atomic unit. Size and timeout limits remain an application-level concern.

### Out of Scope

The following features are explicitly **out of scope** for Version 1:

- **Chunked encryption** for large files
- **Streaming decryption** for progressive loading
- **Multi-part uploads** with per-chunk keys
- **Cross-group deduplication** (security boundary is the MLS group)

Future versions may address these features, but the base specification focuses on the simpler single-blob case.

## Security Considerations

### Threat Model

This specification protects against:

1. **Storage provider compromise** - Encrypted blobs reveal no information about content
2. **Network surveillance** - All content and metadata are encrypted
3. **Metadata tampering** - AEAD associated data prevents modification
4. **File corruption** - Integrity verification detects corruption

### Security Properties

1. **Confidentiality**: Only current group members can decrypt media
2. **Integrity**: Tampering with encrypted blobs or metadata is detectable
3. **Authenticity**: Media origin is verifiable through MLS group membership
4. **Forward Secrecy**: Historical media becomes inaccessible after MLS epoch changes
5. **Post-Compromise Security**: Future media remains secure after key recovery
