# MIP-03

## Group Messages

`draft` `mandatory`

This document defines Group Events (`kind: 445`) that enable secure group communication in Marmot Protocol. Group Events include both control messages (Proposals and Commits) and application messages (regular chat content).

## Overview

Group Events are how members communicate within a group. They provide:

- **Control messages**: `Proposal` and `Commit` messages that update group membership and settings
- **Application messages**: Regular chat messages, reactions, and other content shared between members
- **Privacy protection**: Content encryption and metadata protection for all group communication

## Privacy Protection

To protect member privacy, Group Events use special techniques:

- **Ephemeral keys**: Each Group Event uses a fresh, one-time Nostr keypair
- **Content encryption**: Messages are encrypted so only group members can read them
- **Metadata protection**: Observers can't easily determine group size or member identities

## Group Event Structure

```json
{
  "id": "ghi789...",
  "kind": 445,
  "created_at": 1693876700,
  "pubkey": "03b2c4d6e8f0a1b3c5d7e9f1a3b5c7d9e1f3a5b7c9d1e3f5a7b9c1d3e5f7a9b1c3",
  "content": "a1b2c3d4e5f6...",
  "tags": [
    ["h", "group_id_from_nostr_extension"]
  ],
  "sig": "506070809..."
}
```

### Field Details

- **`content`**: Serialized [`MLSMessage`](https://www.rfc-editor.org/rfc/rfc9420.html#section-6-4) encrypted with [NIP-44](44.md)
- **`pubkey`**: Ephemeral public key (different for each Group Event)
- **`h` tag**: Group ID from the Nostr Group Data Extension

## Encryption Details

### Content Encryption Process

1. **Get group secret**: Use the MLS `exporter_secret` from the current group epoch
2. **Generate keypair**: Create a Nostr keypair using the `exporter_secret` as the private key
3. **Apply NIP-44**: Encrypt the MLSMessage using the standard NIP-44 scheme. However, instead of using the sender and receivers keys to derive a `conversation_key`, the NIP-44 encryption is done using a Nostr keypair generated from the MLS [`exporter_secret`](https://www.rfc-editor.org/rfc/rfc9420.html#section-8.5) to calulate the `conversation_key` value. Essentially, you use the hex-encoded `exporter_secret` value as the private key (used as the sender key), calculate the public key for that private key (used as the receiver key), and then proceed with the standard NIP-44 scheme to encrypt and decrypt messages.
4. **Publish**: Publish the event to relays using an ephemeral keypair.

### Key Technical Details

- **`exporter_secret`**: 32-byte value labeled `nostr`, rotates with each group epoch
- **Ephemeral keys**: Each Group Event uses a fresh keypair derived from the `exporter_secret`
- **Group ID**: Taken from the Nostr Group Data Extension for message routing

> **Security Note**: The `exporter_secret` ensures only current group members can decrypt messages, and it rotates automatically when the group state changes.

## Proposal and Commit Messages

### Two-Phase Group Changes

Group modifications use a two-phase approach for safety and coordination:

1. **Proposal Phase**: Members suggest changes
2. **Commit Phase**: Admins approve and apply changes

### Proposal Messages

**Who can propose**: Any group member can create proposals

**What proposals do**:
- Suggest adding new members
- Propose removing members
- Recommend changing group settings
- Request key rotations

**Proposal lifecycle**:
- Created by any member
- Stored for review
- Included (or rejected) in future Commits

### Commit Messages

**Who can commit**: Only group admins can create and send Commits

**What commits do**:
- Apply one or more pending proposals
- Update the group's cryptographic state
- Move the group to a new "epoch" (version)

**Security requirements**:
- Sender MUST be listed in `admin_pubkeys` (see [MIP-01](01.md))
- Clients MUST verify admin status before processing any Commit
- Invalid Commits from non-admins MUST be rejected

> **Admin Control**: This design ensures only authorized admins can make actual changes to groups, while still allowing all members to participate in governance through proposals.

### Commit Message Race Conditions

#### The Challenge

While MLS handles most out-of-order messages gracefully, `Commit` message ordering is critical for proper group state progression. In Nostr's decentralized environment, multiple admins might send competing Commits simultaneously.

#### Prevention Strategy

**Wait for confirmation**: Clients sending Commits MUST:
1. **Send the Group Event**: Publish the Commit as a Group Event to relays
2. **Wait for acknowledgment**: Don't apply the Commit locally until at least one relay confirms receipt
3. **Then apply locally**: Only then update your own group state

#### Conflict Resolution

When receiving multiple Commits for the same epoch, clients MUST apply exactly one using this priority:

1. **Timestamp priority**: Choose the Commit with the earliest `created_at` timestamp
2. **ID tiebreaker**: If timestamps are identical, choose the Commit with the lexicographically smallest `id`
3. **Discard others**: Reject all other competing Commits

#### Recovery Mechanism

**State backup**: Clients SHOULD retain previous group states temporarily to enable recovery from forked states.

**Example scenario**:
- Admin A and Admin B both send Commits at timestamp 1693876800
- Admin A's Commit has ID "aaa123...", Admin B's has "bbb456..."
- All clients apply Admin A's Commit (lexicographically smaller ID)
- Admin B's Commit is discarded

> **Consistency Note**: This deterministic ordering ensures all honest clients converge on the same group state, even with competing Commits.

## Application Messages

### What are Application Messages?

Application messages are the regular content shared within groups - chat messages, reactions, media sharing, and any other member-to-member communication.

### Message Format

Application messages use standard Nostr event formats inside the encrypted MLS envelope:

- **Chat messages**: `kind: 9` events for regular text messages
- **Reactions**: `kind: 7` events for emoji reactions to other messages
- **Other content**: Any appropriate Nostr event kind

### Benefits of Nostr Events Inside MLS

This approach provides the best of both worlds:
- **MLS security**: End-to-end encryption and forward secrecy
- **Nostr features**: Rich event types, reactions, threading, and extensibility
- **Familiar handling**: Clients can reuse existing Nostr event processing logic

### Security Requirements

**Identity verification**:
- Inner events MUST use the sender's Nostr identity key in the `pubkey` field
- Clients MUST verify the MLS sender matches the inner event's pubkey

**Prevent leaks**:
- Inner events MUST remain **unsigned** (no `sig` field)
- MUST NOT include `h` tags or other group identifiers
- This ensures leaked events cannot be published to public relays

### Example Flow

1. **Create**: Member creates a `kind: 9` chat message event (unsigned)
2. **Wrap**: Event is serialized and wrapped in an MLS Application message
3. **Encrypt**: MLS message is encrypted and sent as a Group Event
4. **Decrypt**: Recipients decrypt and deserialize to get the original Nostr event
5. **Store**: Clients can store and display the event like any other Nostr content

## Summary

### Key Components

1. **Group Events** (`kind: 445`): Encrypted container for all group communication
2. **Proposal Messages**: Member-initiated suggestions for group changes
3. **Commit Messages**: Admin-authorized group state changes
4. **Application Messages**: Regular content using Nostr event formats

### Security Features

- **End-to-end encryption**: Only group members can read messages
- **Forward secrecy**: Past messages stay secure even if keys are compromised
- **Privacy protection**: Ephemeral keys hide member identities from observers
- **Admin controls**: Only authorized admins can modify group membership
- **Race condition handling**: Deterministic conflict resolution for competing Commits

### Requirements for Implementers

**MUST implement**:
- Admin verification for all Commit messages
- Race condition handling for competing Commits
- Proper key generation from `exporter_secret`
- Proper NIP-44 encryption of message content using `exporter_secret`
- Identity verification for inner application messages
- Unsigned inner events to prevent leaks

**Security considerations**:
- Never reuse ephemeral keypairs for Group Events
- Verify all admin permissions before processing Commits
- Handle unsigned inner events to prevent leaks
- Implement proper conflict resolution for Commits
